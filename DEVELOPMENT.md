# 開発ドキュメント

## 開発状況

### ステップ 1: 開発環境の構築 ✅ 完了

- [x] プロジェクト初期化（uv）
- [x] 依存関係の設定（numpy, streamlit）
- [x] MVCモデルに基づくフォルダ構造の構築
- [x] 基本クラスの実装とテスト

#### 実装済みクラス

| クラス | ファイル | 説明 | テスト |
|--------|---------|------|--------|
| `Suit` | `src/models/suit.py` | 8種類のスートを表すEnum | - |
| `Card` | `src/models/card.py` | カードクラス（スート+数値1-10） | ✅ 7テスト |
| `Deck` | `src/models/deck.py` | 山札クラス（80枚→10枚除外→70枚） | ✅ 6テスト |
| `Hand` | `src/models/hand.py` | 手札クラス | ✅ 7テスト |
| `FieldSlot` | `src/models/field_slot.py` | スロット（カードの山）クラス | ✅ 4テスト |
| `Field` | `src/models/field.py` | 場クラス（2つのスロット） | ✅ 6テスト |
| `PointCalculator` | `src/models/point_calculator.py` | ポイント計算ロジック | ✅ 11テスト |

**ステップ1 テスト数**: 41個 / 全て通過 ✅

### ステップ 2: ゲームロジックの実装 ✅ 完了

#### 実装済みクラス

| クラス | ファイル | 説明 | テスト |
|--------|---------|------|--------|
| `MoveValidator` | `src/controllers/move_validator.py` | 合法手判定ロジック | ✅ 12テスト |
| `GameState` | `src/controllers/game_state.py` | ゲーム状態管理 | ✅ 8テスト |
| `Game` | `src/controllers/game.py` | ゲーム全体のフロー制御 | ✅ 10テスト |

**ステップ2 テスト数**: 30個 / 全て通過 ✅

#### 実装機能

1. ✅ **合法手判定** - 同じスートまたは同じ数値のカードを出せる
2. ✅ **ゲーム状態管理** - 手札、場、山札、ポイントを管理
3. ✅ **ランダムシミュレーション** - ゲームを自動でプレイ
4. ✅ **ゲーム終了判定** - 出せるカードがなくなったら終了
5. ✅ **統計情報収集** - 複数回のシミュレーション結果を分析

#### パフォーマンス（ランダム戦略）

- **平均カード枚数**: 6.4枚 / 70枚
- **平均ポイント**: 0.1ポイント
- **ターン数**: 平均6.4ターン

### ステップ 3: 最適解探索アルゴリズムの実装 ✅ 完了

#### 実装済みクラス

| クラス | ファイル | 説明 | テスト |
|--------|---------|------|--------|
| `Evaluator` | `src/controllers/evaluator.py` | ゲーム結果の評価関数 | ✅ 11テスト |
| `MCTSNode` | `src/controllers/mcts_node.py` | MCTS木のノード（UCB1） | ✅ 12テスト |
| `MCTSEngine` | `src/controllers/mcts_engine.py` | MCTS 4フェーズアルゴリズム | ✅ 10テスト |
| `MCTSStrategy` | `src/controllers/mcts_strategy.py` | MCTS戦略のユーザーAPI | ✅ 10テスト |

**ステップ3 テスト数**: 43個 / 全て通過 ✅
**総テスト数**: 114個 / 全て通過 ✅

#### アルゴリズム詳細

**モンテカルロ木探索（MCTS）**を採用：

1. ✅ **選択 (Selection)** - UCB1スコアで最も有望なノードを選択
   - UCB1 = 平均報酬 + C × √(ln(親の訪問数) / ノードの訪問数)
   - 探索重み C = 1.41 (√2)

2. ✅ **展開 (Expansion)** - 新しい子ノードを追加

3. ✅ **シミュレーション (Simulation)** - ランダムプレイアウトで結果を取得

4. ✅ **逆伝播 (Backpropagation)** - 結果をルートまで伝播

#### 評価関数

```
スコア = (場に出したカード枚数 × 10) + (獲得ポイント × 1)
```

**優先度**:
1. カード枚数の最大化（最優先）
2. ポイントの最大化（次点）

#### パフォーマンス（MCTS戦略 vs ランダム戦略）

**ベンチマーク設定**: 20ゲーム、500反復/手

| 指標 | ランダム | MCTS | 改善度 |
|------|---------|------|--------|
| **平均カード枚数** | 6.40枚 | **17.80枚** | **+178.1%** ✅ |
| **最大カード枚数** | 16枚 | **50枚** | **+212.5%** |
| **平均ポイント** | 0.10pt | 0.10pt | +0.0% |
| **最大ポイント** | 2pt | 2pt | - |

**結論**: MCTSは**大幅な改善**を達成！ 🎉

#### 実装機能

1. ✅ **評価関数** - カード枚数とポイントを総合評価
2. ✅ **UCB1探索** - 探索と活用のバランス
3. ✅ **MCTSアルゴリズム** - 4フェーズの探索サイクル
4. ✅ **戦略API** - ユーザー向けの高レベルインターフェース
5. ✅ **パフォーマンス比較** - ランダムとMCTSの統計比較
6. ✅ **再現性保証** - シード値による結果の再現性

### ステップ 4: WebUIアプリケーションの実装 ✅ 完了

#### 実装ファイル

| ファイル | 説明 | テスト |
|---------|------|--------|
| `app.py` | Streamlit WebUIアプリケーション | - |
| `WEBUI_GUIDE.md` | WebUI使用方法ドキュメント | - |

**ステップ4追加ファイル**: 2個

#### 実装機能

1. ✅ **ゲーム状態表示** - 手札、場、山札、統計情報
2. ✅ **最適解分析** - MCTS戦略による次の手の推奨
3. ✅ **インタラクティブプレイ** - ボタンクリックで手を実行
4. ✅ **設定調整** - MCTS探索回数の調整（50-2000回）
5. ✅ **履歴管理** - プレイした手の履歴表示
6. ✅ **ゲームリセット** - 新しいゲームの開始
7. ✅ **視覚的表現** - カードの色分け、スロット状態の表示
8. ✅ **統計情報** - リアルタイムのスコア計算

#### WebUI機能詳細

**画面構成**:
- **ヘッダー**: タイトルと説明
- **統計パネル**: ターン数、カード枚数、ポイント、スコア
- **場の表示**: 2つのスロットのトップカード（スート絵文字付き）
- **手札の表示**: 現在の手札（色分け表示、スート絵文字付き）
- **📊 山札状況表**: 全80枚のカードを8スート×10数値の表形式で表示
  - 🟥 赤色: 推奨カード（次に使うべきカード）
  - 🟨 黄色: 手札のカード
  - 薄い数値: 使用済みカード（場に出したカード）
  - 空欄: 山札に含まれないカード（初期の10枚除外）
  - 通常: 山札に残っているカード
- **🎯 除外カード・初期手札選択ダイアログ**: 2ステップで完全指定可能
  - ステップ1: 除外カード10枚選択
  - ステップ2: 初期手札5枚選択
- **最適解パネル**: MCTS推奨手と実行ボタン
- **履歴**: プレイした手の記録（スート絵文字付き）

**サイドバー**:
- MCTS探索回数の調整
- ゲーム情報（シード、ターン）
- 新しいゲーム開始ボタン（ランダム）
- 除外カード指定ゲーム開始ボタン
- ルール説明

#### 起動方法

```powershell
uv run streamlit run app.py
```

ブラウザで http://localhost:8501 にアクセス

**総テスト数**: 115個 / 全て通過 ✅

### ステップ 5: WebUIリファクタリング ✅ 完了

#### リファクタリングの目的

`app.py`が661行に肥大化し、保守性・拡張性に課題があったため、MVCモデルに基づいてビュー層を分割。

#### 実装ファイル

**新しいビュー層の構造**:

```
src/views/
├── components/              # UIコンポーネント (5ファイル)
│   ├── game_state_display.py      # ゲーム状態表示
│   ├── hand_display.py             # 手札表示
│   ├── field_display.py            # 場表示
│   ├── deck_status_display.py     # 山札状況表示
│   └── card_selection_table.py    # カード選択テーブル
├── dialogs/                 # ダイアログ (2ファイル)
│   ├── exclude_card_dialog.py     # 除外カード選択
│   └── hand_selection_dialog.py   # 初期手札選択
├── styles/                  # スタイル定義 (1ファイル)
│   └── card_table_styles.py       # CSSスタイル
└── utils/                   # ユーティリティ (2ファイル)
    ├── ui_helpers.py              # UI補助関数
    └── session_manager.py         # セッション管理
```

**テストファイル**:
- `tests/test_app_behavior.py`: リファクタリング前後の動作保証テスト（11テスト）

#### リファクタリング成果

| 指標 | リファクタリング前 | リファクタリング後 | 改善度 |
|------|-------------------|-------------------|--------|
| **app.pyの行数** | 661行 | **244行** | **-63%削減** ✅ |
| **ファイル数** | 1ファイル | 11ファイル | モジュール化 |
| **保守性** | 低い | **高い** | 各機能が独立 |
| **拡張性** | 困難 | **容易** | コンポーネント追加が簡単 |
| **テスト容易性** | 困難 | **容易** | 個別にテスト可能 |
| **再利用性** | 不可 | **可能** | 他プロジェクトでも利用可 |
| **動作保証** | - | **11/11テスト成功** | 同じ動作を保証 |

#### 実装機能

1. ✅ **コンポーネント分割** - UI表示機能を5つのコンポーネントに分離
2. ✅ **ダイアログ分離** - 2つのダイアログを独立ファイル化
3. ✅ **スタイル管理** - CSSスタイルを専用モジュール化
4. ✅ **セッション管理** - Streamlitセッション状態を専用モジュール化
5. ✅ **テスト保証** - リファクタリング前後で同じ動作を保証するテスト
6. ✅ **ドキュメント更新** - PROJECT_STRUCTURE.md、DEVELOPMENT.mdを更新

**ステップ5 テスト数**: 11個 / 全て通過 ✅
**総テスト数**: 126個 / 全て通過 ✅

### ステップ 6: ヒューリスティック戦略の実装 ✅ 完了

#### 背景と動機

**課題**: MCTS戦略は完全情報（山札の順番がわかる）を前提としているため、実際のゲームプレイでは使用できない。また、実行時間が長い（1-30秒/手）ため、リアルタイム使用に不向き。

**解決策**: 不完全情報（山札の順番がわからない）下で動作する高速なヒューリスティック戦略を実装。

#### 実装クラス

| クラス | ファイル | 説明 | テスト |
|--------|---------|------|--------|
| `ObservableGameState` | `src/controllers/observable_game_state.py` | 不完全情報ゲーム状態管理 | ✅ 6テスト |
| `FlexibilityCalculator` | `src/controllers/flexibility_calculator.py` | カード柔軟性スコア計算 | ✅ 12テスト |
| `HeuristicStrategy` | `src/controllers/heuristic_strategy.py` | 柔軟性ベース戦略 | ✅ 8テスト |

**ステップ6 テスト数**: 26個 / 全て通過 ✅
**総テスト数**: 152個 / 全て通過 ✅

#### アルゴリズム詳細

**柔軟性スコアに基づくヒューリスティック**:

1. **柔軟性スコア計算**: 各カードが未知の山札のカードと接続できる可能性を数値化
   - 柔軟性スコア = 同じスートのカード数 + 同じ数値のカード数
   - 高いスコア = 将来的に出せる可能性が高い
   - 低いスコア = 今出さないと後で出せない可能性が高い

2. **戦略ロジック**: 残りの合法手の柔軟性スコアの合計が最大になる手を選択
   - 各合法手を実行した場合の「残りの手札カードの柔軟性合計」を計算
   - 柔軟性合計が最大になる手 = 柔軟性が最も低いカードを出す手
   - タイブレーク: 同点の場合は個別の柔軟性が低いカードを優先

3. **最適化**: O(n×m) → O(n+m) に計算量を削減（スート・数値インデックス使用）

#### パフォーマンス（ヒューリスティック vs ランダム）

**ベンチマーク設定**: 各100ゲーム

| 指標 | ランダム | ヒューリスティック | 改善度 |
|------|---------|-------------------|--------|
| **平均カード枚数** | 6.47枚 | **7.70枚** | **+19.0%** ✅ |
| **中央値** | 5.00枚 | **6.00枚** | **+20.0%** |
| **最大カード枚数** | 26枚 | **48枚** | **+84.6%** |
| **平均ポイント** | 0.00pt | 0.04pt | - |
| **実行時間** | <0.001秒 | **0.0018秒** | **即座** ⚡ |

**3戦略の比較**:

| 戦略 | 平均枚数 | 実行時間 | 使用場面 |
|------|---------|---------|---------|
| ランダム | 6.47枚 | <0.001秒 | ベースライン |
| **ヒューリスティック** | **7.70枚** | **0.002秒** | **通常プレイ（推奨）** ⚡ |
| MCTS | 17.8枚 | 1-30秒 | ベストスコア狙い |

**結論**: ヒューリスティック戦略は、**MCTS戦略の1000倍以上高速**でありながら、**ランダム戦略より19%改善**を達成。リアルタイム使用に最適。

詳細な評価結果は [PERFORMANCE_EVALUATION.md](PERFORMANCE_EVALUATION.md) を参照。

#### WebUI統合

**app.py への統合**:

1. ✅ **戦略選択UI** - サイドバーでヒューリスティック/MCTSを選択
2. ✅ **戦略説明表示** - ヒューリスティック戦略の選択理由を表示
3. ✅ **条件付き設定** - MCTS選択時のみ探索回数設定を表示
4. ✅ **リアルタイム分析** - 即座に推奨手を表示

#### ベンチマークスクリプト

| ファイル | 説明 |
|---------|------|
| `benchmark_heuristic.py` | ヒューリスティック戦略の性能評価（100ゲーム） |
| `benchmark_random.py` | ランダム戦略の性能評価（100ゲーム、比較用） |
| `benchmark_mcts.py` | MCTS戦略の性能評価（20ゲーム） |

#### 実装機能

1. ✅ **不完全情報管理** - 既知カードと未知カードの分離
2. ✅ **柔軟性計算** - カードの接続可能性スコアリング
3. ✅ **戦略API** - 説明付き最適手の提案
4. ✅ **性能最適化** - O(n+m)計算量への改善
5. ✅ **WebUI統合** - 戦略選択とリアルタイム分析
6. ✅ **ベンチマーク** - 3戦略の詳細な性能比較
7. ✅ **ドキュメント** - 評価レポート作成（PERFORMANCE_EVALUATION.md）

**総テスト数**: 152個 / 全て通過 ✅

## コーディング規約

### ファイル命名規則

- **ファイル名**: スネークケース（例: `point_calculator.py`）
- **クラス名**: パスカルケース（例: `PointCalculator`）
- **関数/変数名**: スネークケース（例: `calculate_points`）

### プロジェクト構造規則

1. **1クラス1ファイル**の原則を守る
2. **ファイル名とクラス名を一致**させる
   - 例: `PointCalculator`クラス → `point_calculator.py`
3. **MVCモデル**に基づく配置
   - Models: `src/models/` - データとビジネスロジック
   - Controllers: `src/controllers/` - ゲームフロー制御
   - Views: `src/views/` - UI層（Streamlit）

### テスト規約

- **関数ごと**にテストケースを作成
- テストファイル名: `test_<モジュール名>.py`
- テストクラス名: `Test<クラス名>`
- テストメソッド名: `test_<機能説明>`

## テスト実行コマンド

### 全テスト実行

```powershell
uv run python -m unittest discover -s tests -p "test_*.py" -v
```

### 特定のテストファイル実行

```powershell
uv run python -m unittest tests.test_card -v
```

### 特定のテストクラス実行

```powershell
uv run python -m unittest tests.test_card.TestCard -v
```

### 特定のテストメソッド実行

```powershell
uv run python -m unittest tests.test_card.TestCard.test_card_creation_valid -v
```

## 開発フロー

1. **機能設計** - 実装するクラス/メソッドを設計
2. **テストコード作成** - テストケースを先に作成（TDD）
3. **実装** - 機能を実装
4. **テスト実行** - テストが通ることを確認
5. **リファクタリング** - コードを最適化
6. **ドキュメント更新** - このファイルとREADMEを更新

## 変更履歴

### 2025-10-13

#### ステップ1完了
- 開発環境構築、基本クラス実装
- MVCモデルに基づくフォルダ構造に変更
- `points.py` → `point_calculator.py`にリネーム
- 全41テスト通過確認
- ドキュメント整備

#### ステップ2完了
- ゲームロジック層の実装（MoveValidator, GameState, Game）
- 合法手判定機能の実装
- ランダムシミュレーション機能の実装
- 全30テスト追加・通過確認（総計71テスト）
- main.pyにシミュレーションデモ追加
- ドキュメント更新

#### リファクタリング: 1クラス1ファイル原則の徹底
- `card.py`から`Suit`を分離 → `suit.py`作成
- `field.py`から`Slot`を分離 → `field_slot.py`作成、`FieldSlot`にリネーム
- 全テストのインポートパス更新
- 全70テスト通過確認

#### ステップ3完了
- MCTS（モンテカルロ木探索）アルゴリズムの実装
- 評価関数とUCB1探索の実装
- ベンチマークによるパフォーマンス検証（+178.1%改善）
- 全43テスト追加・通過確認（総計114テスト）
- ドキュメント更新

#### ステップ4完了
- Streamlit WebUIアプリケーションの実装
- ゲーム状態の視覚化、最適解分析、履歴管理
- 山札状況表示（8×10テーブル）
- 除外カード・初期手札の指定機能
- WEBUI_GUIDE.md作成

#### ステップ5完了: WebUIリファクタリング

- app.pyを661行から244行に削減（-63%）
- MVCモデルに基づくビュー層の分割（11ファイル）
- components, dialogs, styles, utilsに機能を分離
- リファクタリング前後の動作保証テスト（11テスト追加）
- 全126テスト通過確認
- ドキュメント更新（PROJECT_STRUCTURE.md, DEVELOPMENT.md）

### 2025-10-14

#### ステップ6完了: ヒューリスティック戦略の実装

- 不完全情報ゲーム対応（ObservableGameState）
- 柔軟性スコア計算（FlexibilityCalculator、O(n+m)最適化）
- ヒューリスティック戦略（HeuristicStrategy、説明付き）
- 全26テスト追加・通過確認（総計152テスト）
- WebUI統合（戦略選択UI、説明表示）
- 性能評価（100ゲーム×3戦略）
  - ランダム: 平均6.47枚
  - ヒューリスティック: 平均7.70枚（+19.0%改善）
  - MCTS: 平均17.8枚（+178%改善）
- ベンチマークスクリプト作成（benchmark_heuristic.py, benchmark_random.py）
- 性能評価レポート作成（PERFORMANCE_EVALUATION.md）
- ドキュメント更新（README.md, WEBUI_GUIDE.md, DEVELOPMENT.md）
